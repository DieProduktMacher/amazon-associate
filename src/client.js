// Generated by CoffeeScript 1.6.3
var Digest, UnzippingResponseDecorator, http, https, url, _,
  __slice = [].slice;

https = require('https');

http = require('http');

url = require('url');

_ = require('underscore');

Digest = require('./digest');

UnzippingResponseDecorator = require('./unzipping-response-decorator');

module.exports = (function() {
  function _Class(options) {
    this.options = options;
    this.digests = {};
  }

  _Class.prototype.debug = function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if (this.options.debug) {
      return console.error.apply(console, ['DEBUG: request'].concat(__slice.call(args)));
    }
  };

  _Class.prototype.request = function(options, cb) {
    var clonedOptions, currentDigest, httpOrHttps, req,
      _this = this;
    if (options.unzip == null) {
      options.unzip = false;
    }
    this.debug('options', options);
    currentDigest = this.digests[options.host];
    clonedOptions = _.extend({}, options);
    if (currentDigest != null) {
      if (clonedOptions.headers == null) {
        clonedOptions.headers = {};
      }
      _.extend(clonedOptions.headers, {
        Authorization: currentDigest
      });
    }
    httpOrHttps = options.https ? https : http;
    req = httpOrHttps.request(clonedOptions, function(res) {
      var handler, handlers, msg;
      _this.debug('response status code', res.statusCode);
      _this.debug('response headers', res.headers);
      res.on('close', function(err) {
        return _this.debug('response error', err);
      });
      handlers = {};
      handlers[200] = function() {
        if (options.unzip) {
          return cb(null, new UnzippingResponseDecorator(res));
        }
        res.setEncoding('utf-8');
        return cb(null, res);
      };
      handlers[301] = handlers[302] = function() {
        var location, parsedUrl;
        _this.debug('moved', res.headers);
        location = res.headers.location;
        _this.debug('moved to', location);
        parsedUrl = url.parse(location);
        _this.debug('redirect location', parsedUrl);
        return _this.request(_.extend({}, parsedUrl, {
          https: parsedUrl.protocol === 'https',
          state: options.state,
          unzip: options.unzip
        }), cb);
      };
      handlers[401] = function() {
        var challenge, credentials, digest, msg1, msg2, _ref, _ref1;
        msg1 = 'wrong credentials';
        if (currentDigest != null) {
          return cb(new Error(msg1));
        }
        msg2 = 'authentication required, but `digest` option is not set';
        credentials = (_ref = _this.options) != null ? (_ref1 = _ref.credentials) != null ? _ref1[options.host] : void 0 : void 0;
        if (credentials == null) {
          return cb(new Error(msg2));
        }
        _this.debug('not authorized: authorizing');
        challenge = Digest.parseChallenge(res.headers['www-authenticate']);
        _this.debug('challenge:', challenge);
        digest = Digest.renderDigest(challenge, credentials.username, credentials.password, options.path);
        _this.digests[options.host] = digest;
        _this.debug('digest:', digest);
        return _this.request(_.extend({}, options), cb);
      };
      handler = handlers[res.statusCode];
      msg = "failed to get " + options.path + ". server status " + res.statusCode;
      if (handler == null) {
        return cb(new Error(msg));
      }
      return handler();
    });
    return req.end();
  };

  return _Class;

})();
